/*
 * Copyright (c) 2018 Luca Beurer-Kellner
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Luca Beurer-Kellner - Initial API and implementation
 */

/**
 * Main-module which implements a mini-tool for the visualisation 
 * of graphs as generated by {@code RandomGraphGenerator}.
 * 
 * This tools is based on Cytoscape.js (http://js.cytoscape.org/) and the
 * Directed Graph Layout Algorithm as implemented by https://github.com/dagrejs/dagre.
 */
 
const cytoscape = require("cytoscape");
const RandomGraphGenerator = require("../RandomGraphGenerator");
const dagre = require("cytoscape-dagre");

// register cytoscape-dagre extension
cytoscape.use(dagre);

/**
 * Compute new random seed.
 */
function randomSeed() {
	return Math.floor(Math.random() * 123489103);
}

/**
 * Computes new random seed, replaces the value of the seed-input field
 * and triggers the graph rendering.
 */
function random() {
	const seedInput = document.getElementById("seed");
	seedInput.value = randomSeed();

	render();
}

/**
 * Renders a new graph with the currently specified basis parameters (input controls).
 */
function render() {
	// initialize counter for node IDs
	let idCounter = 0;
	
	// initialize nodes and edges for the cytoscape model 
	let nodes = [];
	let edges = [];
	
	// keep track of visited nodes to guard against
	// circular graphs
	let visited = []

	// simple node factory which returns plain objects
	// of structure: {id : number, successors : [Node]}
	const nodeFactory = () => {
		return {
			id: idCounter++,
			successors: []
		}
	}

	/** 
	* Builds a cytoscape model (stores it to {@code nodes} and {@code edges}
	* by traversing the graph which starts with {@code root}.
	* 
	* @param root The traversal root
	* @param isRoot Specifies whether this is the initial invokation of this recursive function. 
	*/
	const buildCytoscapeModel = (root, isRoot = true) => {
		// recursion guard
		if (visited.indexOf(root) != -1) {
			return;
		}
		// mark current node as visited
		visited.push(root);
		// add cytoscape node for node instance
		if (isRoot) {
			nodes.push({ data: { id: "n" + root.id, root: true } })
		} else {
			nodes.push({ data: { id: "n" + root.id } })
		}
		// add edges for all successors
		root.successors.forEach(s => {
			edges.push({ data: { source: 'n' + root.id, target: 'n' + s.id } })
		});

		// traverse all successor nodes
		root.successors.map(s => buildCytoscapeModel(s, false));
	}
	
	// parse parameters from control input fields
	const seed = parseFloat(document.getElementById("seed").value) 
		|| randomSeed(); // fall-back to a random seed, if input can't be parsed
	const numberOfNodes = parseFloat(document.getElementById("number-of-nodes").value);
	const numberOfEdges = parseFloat(document.getElementById("number-of-edges").value);
	
	// validate input to be valid numbers
	if (isNaN(numberOfNodes)) {
		alert("Failed to parse value for Number of Nodes.")
		return;
	}

	if (isNaN(numberOfEdges)) {
		alert("Failed to parse value for Maximum # of Outgoing Edges.")
		return;
	}

	// make sure seed is reflected by UI
	document.getElementById("seed").value = seed;

	// build the cytoscape model from a random graph
	buildCytoscapeModel(RandomGraphGenerator.randomGraph(seed, numberOfNodes, numberOfEdges, nodeFactory));

	// trigger graph rendering in DOM element #graph
	cytoscape({
		container: document.getElementById('graph'),

		boxSelectionEnabled: false,
		autounselectify: true,

		layout: {
			name: 'dagre'
		},

		style: [
			{
				selector: 'node',
				style: {
					'content': 'data(id)',
					'text-opacity': 0.5,
					'text-valign': 'center',
					'text-halign': 'right',
					'background-color': '#11479e'
				}
			},
			{
				selector: 'node[root]',
				style: {
					'background-color': 'green'
				}
			},
			{
				selector: 'edge',
				style: {
					'curve-style': 'bezier',
					'width': 4,
					'target-arrow-shape': 'triangle',
					'line-color': '#9dbaea',
					'target-arrow-color': '#9dbaea'
				}
			}
		],

		elements: {
			nodes: nodes,
			edges: edges
		},
	});
}
// register button listeners
document.querySelector("button#random").addEventListener("click", random);
document.querySelector("button#render").addEventListener("click", render);

// generate random graph on page load
random();