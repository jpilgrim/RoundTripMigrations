// @section v1
export public class CollectFieldMultiRef#1 {
	public references : Array<SourceClass>
}
export public class Element#1 {
	public value : string
}

export public class SourceClass#1 {
	public field : Element
	public uncollectedField : string
}

// @section v2
export public class CollectFieldMultiRef#2 {
	public references : Array<SourceClass>
	public fieldValues : Array<Element>
}

export public class Element#2 {
	public value : string
}

export public class SourceClass#2 {
	public uncollectedField : string
}

// @section migrations
@Migration function migrateCollectField(cf : CollectFieldMultiRef#1) : CollectFieldMultiRef#2 {
	const cf2 = new CollectFieldMultiRef#2();
	
	// migrate SourceClass#1 instances to array of SourceClass#2 instances
	cf2.references = cf.references.map(r => { return migrate(r, false); }) as [SourceClass#2]
	// migrate SourceClass#1 instances to array of Element#2 instances
	cf2.fieldValues = cf.references.map(r => { return migrate(r, true); }) as [Element#2]
	
	return cf2;
}

/**
 * Returns the corresponding Element#2 instance of a given
 * SourceClass#2 using trace links.
 * 
 * Returns {@code null} if no corresponding instance can be obtained.
 */
@VersionAware
function getElementOfSourceClass(context : MigrationContext, 
	cf : CollectFieldMultiRef#2, sc : SourceClass#2) : Element#2 {
	
	// create reverse-lookup map, to obtain Element#2 instances 
	// of a given SourceClass#2 instance
	const elementsBySourceClass = new Map<SourceClass#1, Element#2>();
	cf.fieldValues.forEach(e => {
		const prev = context.getTrace(e)[0] as SourceClass#1;
		if (prev != null) {
			elementsBySourceClass.set(prev, e);
		}
	});
	const prev = context.getTrace(sc)[0] as SourceClass#1;
	if (prev != null) {
		return elementsBySourceClass.get(prev);
	} else {
		return null;
	}
}

@Migration function migrateBackCollectField(cf : CollectFieldMultiRef#2) : CollectFieldMultiRef#1 {
	const cf1 = new CollectFieldMultiRef#1();
	
	// undo collection of 'field' into 'fieldValues' from 'references'
	cf1.references = cf.references.map(sc => {
		// obtain corresponding Element#2 instance
		const element = getElementOfSourceClass(context, cf, sc);
		// if the corresponding Element#2 could be determined
		if (element != null) {
			// migrate Element#2 to version 1 and use it
			// to migrate sc back
			const migratedElement : Element#1 = migrate(element);
			return migrate(sc, migratedElement);
		} else {
			// otherwise migrate sc using default Element#1 instance
			return migrate(sc, createDefaultElement());
		}
	})
	
	return cf1;
}

@VersionAware function createDefaultElement() : Element#1 {
	const e = new Element#1();
	e.value = "defaultValue";
	return e;
}

/** Migrates a SourceClass#1 instance to a SourceClass#2 instance or alternatively
 * to an Element#2 instance (see parameter toElement). */
@Migration(1,2) function migrateSourceClassRef(sc : SourceClass#1, toElement : boolean) : Object {
	// if specified, migrate to an instance of Element#2
	if (toElement) {
		const e2 = new Element#2();
		e2.value = sc.field.value;
		return e2;
	}
	
	// otherwise, migrate to an instance of SourceClass#2 
	const sc2 = new SourceClass#2();
	sc2.uncollectedField = sc.uncollectedField;
	return sc2;
}

@Migration(2, 1) function migrateBackSourceClass(sc : SourceClass#2, field : Element#1) : SourceClass#1 {
	const sc1 = new SourceClass#1();
	sc1.field = field;
	sc1.uncollectedField = sc.uncollectedField;
	return sc1;
}

@Migration function migrateBackElement(e : Element#2) : Element#1 {
	const e1 = new Element#1();
	e1.value = e.value;
	return e1;
}