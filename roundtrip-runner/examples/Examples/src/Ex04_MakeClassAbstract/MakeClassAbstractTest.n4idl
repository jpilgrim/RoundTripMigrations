import {AbstractRoundTripTest} from "com/enfore/n4js/n4idl/roundtrip/AbstractRoundTripTest";

import {MakeClassAbstract} from "Ex04_MakeClassAbstract/MakeClassAbstract";

import {Value, Value1, Value2} from "Ex04_MakeClassAbstract/MakeClassAbstract";
import {Assert} from "org/eclipse/n4js/mangelhaft/assert/Assert";

/**
 * MakeClassAbstract
 * 
 * MakeClassAbstract#2 -> MakeClassAbstract#1 -> MakeClassAbstract#2
 * 
 * The class Value is declared abstract in version 2. Thus, all values of 
 * type Value in version 1 have to be migrated to one of Value's concrete 
 * sub-classes of version 2.
 * 
 * Make Class Abstract: unsafely model-migrating
 * Drop Class Abstract: model-preserving
 */
@VersionAware
export public class MakeClassAbstractTest extends AbstractRoundTripTest<MakeClassAbstract#2, MakeClassAbstract#1> {
	
	@Override
	public instantiateOriginal() : MakeClassAbstract#2 {
		return new MakeClassAbstract#2({
			field: new Value1#2({
				commonField: "commonValue", 
				field1: "value1"
			}
		)});
	}
	
	@Override
	public migrate(o2 : MakeClassAbstract#2) : MakeClassAbstract#1 {
		return new MakeClassAbstract#1({
			field: new Value#1({
				commonField: o2.field.commonField,
				field1: (o2.field instanceof Value1#2) ? (o2.field as Value1#2).field1 : "defaultValue1",
				field2: (o2.field instanceof Value2#2) ? (o2.field as Value2#2).field2 : "defaultValue2",
			})
		})
	}

	@Override
	public migrateBack(o1 : MakeClassAbstract#1) : MakeClassAbstract#2 {
		if (o1.field.field1 != "defaultValue1") {
			return new MakeClassAbstract#2({
				field: new Value1#2({
					commonField: o1.field.commonField,
					field1: o1.field.field1	
				})
			});
		} else { // otherwise use field2 no matter what
			return new MakeClassAbstract#2({
				field: new Value2#2({
					commonField: o1.field.commonField,
					field2: o1.field.field2	
				})
			});
		}
	}
	
	@Override
	public assertRoundTripInstance(roundTrip : MakeClassAbstract#2) {
		Assert.isInstanceOf(roundTrip.field, Value1#2, "The field 'field1' is an instance of concrete subclass Value1.");
		Assert.equal((roundTrip.field as Value1#2).field1, "value1", "The field 'field1' has the original value.");
		Assert.equal(roundTrip.field.commonField, "commonValue", "The field 'commonField' has the original value.");	
	}
	@Override
	public assertMigratedInstance(migrated : MakeClassAbstract#1) {
		Assert.isInstanceOf(migrated.field, Value#1, "The migrated instance is of class Value#1.");
		Assert.equal(migrated.field.field2, "defaultValue2", "The field 'field2' is is set to a default value in the migrated instance.");
		Assert.equal(migrated.field.commonField, "commonValue", "The field 'commonField' has the original value.");
		Assert.equal(migrated.field.field1, "value1", "The field 'field1' of the migrated instance has the original value.");
	}
}
	