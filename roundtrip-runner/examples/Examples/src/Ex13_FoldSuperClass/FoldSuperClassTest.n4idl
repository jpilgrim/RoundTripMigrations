import {AbstractRoundTripTest} from "com/enfore/n4js/n4idl/roundtrip/AbstractRoundTripTest";
import {FoldSuperClass} from "Ex13_FoldSuperClass/FoldSuperClass";
import {Assert} from "org/eclipse/n4js/mangelhaft/assert/Assert";

/**
 * FoldSuperClass
 * 
 * FoldSuperClass#1 -> FoldSuperClass#2 -> FoldSuperClass#1
 * 
 * The fields of FoldSuperClass are folded into SuperClass by declaring 'SuperClass'
 * the super class of FoldSuperClass in version 2.
 * 
 * On an instance level this does not have any effect on the set of fields.
 * Thus, migrations can be identity functions besides the change in type version.
 * 
 * In the context of round-trip migrations, this metamodel change may be classified as refactoring.
 * 
 * Fold Super Class: safely model-migrating
 * Unfold Super Class: unsafely model-migrating
 */
@VersionAware
export public class FoldSuperClassTest extends AbstractRoundTripTest<FoldSuperClass#1, FoldSuperClass#2> {
	
	@Override
	public instantiateOriginal() : FoldSuperClass#1 {
		return new FoldSuperClass#1({
			f1: 1,
			f2: 2
		});
	}
	
	@Override
	public migrate(o1 : FoldSuperClass#1) : FoldSuperClass#2 {
		return new FoldSuperClass#2({
			f1: o1.f1,
			f2: o1.f2
		});
	}

	@Override
	public migrateBack(o2 : FoldSuperClass#2) : FoldSuperClass#1 {
		return new FoldSuperClass#1({
			f1: o2.f1,
			f2: o2.f2
		});
	}
	
	@Override
	public assertRoundTripInstance(roundTrip : FoldSuperClass#1) {
		Assert.equal(roundTrip.f1, 1, "The value of field 'f1' of the round-trip instance is retained");
		Assert.equal(roundTrip.f2, 2, "The value of field 'f2' of the round-trip instance is retained");	
	}
	
	@Override
	public assertMigratedInstance(migrated : FoldSuperClass#2) {
		Assert.equal(migrated.f1, 1, "The value of field 'f1' of the migrated instance is retained");
		Assert.equal(migrated.f2, 2, "The value of field 'f2' of the migrated instance is retained");
	}
}
	